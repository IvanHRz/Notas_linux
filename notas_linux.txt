Prompt
El prompt es la linea de nombre de usuario en la shell
nombre de usuario, arroba, nombre de maquina, dos puntos y el directorio actual en el que nos encontramos
----------------------------------------------------------------------------------------------------------------------------
4 Tipos de comandos
lo podemos averiguar con el comando type

1.- Comando implementados en la propia shell - Son comandos implementados en el codigo de la shell, ya vienen por default
si pulsamos el comando type y luego el comando del que tengamos duda y nos aparece el siguiente mensaje "type is a shell builtin"
entonces podemos asumir que el comando viene implementado en el codigo de la shell.

2.- Comandos que no son implementados en la shell, esta implementado por medio de ficheros y tienen una ruta especifica -
es un comando ejecutable externo a la shell y simplemente la shell lo invoca, si ponemos tpe y por ejemplo "cp" nos arrojara
lo siguientye "cp is /usr/bin/cp"

3.- Shell funtions que no son mas que utilidades escritas con un lenguaje de programa con que se denomina shell script
el cual es un lenguage propio de la shell.

4.- Alias - referencia (short cut) de comandos que vienen establecidos o que nosotros podemos crar para simplificar comandsos mas
extensos como ls
---------------------------------------------------------------------------------------------------------------------------
para usar git en linux instalamos meld y y gitg 
+++++++++++++++++++++++++++++++++++++++++++configurar herrmientas+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
git config --global user.name "nombre_del_usuario"
git config --global user.email "email del usuario"

00++++++++++++++++++++++++++++++++usuarios+++++++++++++++++++++++++++++++++++++++++++++++

name: IvanHRz
email: ivan-huerta2020@outlook.com
estos son mis datos de enlace con git y github whoami
paraver cuantos y cuales son los usuarios de una terminal linux usar el sigueinte comando:
cat /etc/passwd             este hasta abajo nos mostrara los usuarios(todos los que tengasn un /home/usuario:bin/bash)
ver lista de usuarios de inicio de sesion en linux: cut -d: -f1 /etc/passwd           en la parte de abajo veremos los usuarios

con el comando: tail     podemos hacer una busqueda e los 10 ultimos usuarios pulsando: tail /etc/passwd  
ubuntu se usa la oreden sudo pero en debian se usa la orden "su", si no especificamos el usuario al que queremos cambiar 
por defecto cambiamos al usuario root del sistema y nos pedira contraseña 
ponermos exit para salir del usuario root
+++++++++++++++++++++++++++++++++++instalar comandos+++++++++++++++++++++++++++++++++++++++++++++++++
ponemos: sudo apt install comando_a_instalar 
++++++++++++++++++++++++++++++++++++vincular carpetas+++++++++++++++++++++++++++++++++++++++++++++++++++
sudo mount -t vboxsf Linux_Debian /home/ivan/Windows 

con ese comando mandamos a llamar a la carpeta que queramos en este caso Linux_Debian y la colocamos en la carpeta Windows 
++++++++++++++++++++++++++++++++extraer archivos .tar+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
tar -xf archive.tar.gz
++++++++++++++++++++++++++++++++extraer archivo .rar+++++++++++++++++++++++++++++++++++++++++++++++
unrar x nobre_del_rar. rar
unrar x nombre_del_rar. rar ruta donde lo queramos descomprimir
sssls 
Comandos:

para ver la ruta de una carpeta en debian poner control + l+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ls lista los archivos de una carpeta
cd entra a una carpeta
pwd te muestra en que carpeta estas  
ls -l mostrar archivos de forma detallada en forma de lista
ls -lh nos indica el tamaño de los archivos 
ls -lS para ordenar alfabeticamente de forma descendiente
ls -lr ordena de orden inverso los archivos 
ls -lt ordenara los archivos dependiendo la modificacion de los mismos 
ls -a muestra archivos ocultos
ls -i muestra el indice de un archivo
ls -lSh para ordenar alfabeticamente y mostrar el tamaño del archivo
ls -lShr para ordenar alfabeticamente de z a A mostrando el peso del archivo
cd .. vamos al directorio anterior
mkdir crea carpetas 
Si quiero usar espacio en un nombre deberé ponerlo entre comillas o con un carácter de escape (\)
nano podemos editar el conntenido de un archivo txt
man podemos ver informacion de algun comando
Direccion de ruta actual ".", direccion de ruta anterior ".."
++++++++++++++++++++++++++++++++++++++++
Ruta relativa y absoluta
basicamente la ruta absoluta es ir a un lugar en especifico de un jalón 
para hacer una ruta absoluta empezamos con unabarra invertida / y luego vamos escribiendo
toda la ruta en un solo comando para llegar a nuestro destino ejemplo: cd/home/alumno/ficheros/ 
ahi llegariamos a ficheros en un solo comando y eso es una ruta absoluta.
La ruta relativa es el llegar a un lugar en especifico por pasos (por varios comandos) 
ejemplo: cd home
luego cd  alumno
luego cd ficheros
eso es una ruta relativa 
++++++++++++++++++++++++++++++++++++++++++
*history  busca tosdos los comandos que has usado y los enumera, luego usando " !numero_de_comando " puedes seleccionar el comando que quieres usar 
*control + r aparece un buscador de comandos, le ponemos las letras que creemos que lleva algun comando que hayamos escrito antes y nos ayuda a buscarlo  
*para crear un arbol de carpeatas usamos mkdir  ponemos mkdir carpeta_existente/nombre_de_carpeta_a_crear 
*si usamos mkdir y ponemos algun elemento no existente en nuestro arbol de carpetas podemos usar -p despues de mkdir y automaticamente se crea, 
ejemplo:
mkdir -p carpeta_padre_inexistente/carpeta_a_crear
*rm -r con esta sentencia podemos borrar un directorio  ejemplo: rm -r carpeta_a_borrar
*rm borra archivos 
*touch nombre_de_archivo.txt con esto creamos un archivo (fichero.txt) dentro de una carpeta (directorio) 
*mv mueve un archivo de un destino a otro y para cambiar el nombre de un archivo (fichero) se toma
el lugar de origen por default (por que ya estas en el otrigen) y solo tienes que escoger el archivo que vas a mover
y el lugar al que lo vas a llevar, puedes  usar rutrelativas o absolutas
ejemplo de ruta relativa:   mv nombre1.txt ..    aqui movemos el archivo a una carpeta anterior 
ejemplo de una ruta absoluta: mv nombre1.txt /home/alumno/ficheros/documentos     aqui movimos un documento a documentos  
*mv tambien sirve para renombrar un rchivo por ejemplo:   mv nombre1.txt  nombre2.txt el nombre 2 seria el nuevo nombre y el 1 el viejo
*cat muestra la informacion de texto de un archivo
*nano podemos editar el contenido de un archivo 
echo "caracteres dentro de un fichero(archivo)  " esto nos sirve para crear contenido dentro de un archivo en este caso una linea de caracteres
echo "conteido" > nombre_de_archivo_a_crear       crea un archivo y le agrega el contenido establecido en las comillas
echo teto con spacios >> archivo_en donde_se_escribira.txt 
El carácter ~ hace referencia al directorio personal del que ejecuta la orden
El comando ls lista el contenido de un directorio. Opciones comunes que modifican cómo se mostrará la información: 
-l lista con detalle, -h muestra el tamaño más legible,
-a muestra los ocultos, -S ordena por tamaño, -t ordena por fecha,
-r invierte el criterio de ordenación

Para indicar dónde se encuentra un elemento del sistema de ficheros (un archivo o un directorio), utilizo rutas. Éstas pueden ser absolutas
(indico todos los directorios que tengo que seguir desde la raíz del sistema) o relativas (indico el camino desde el directorio donde ejecuto
 la orden).
--------------------------------------------------------------------------------------------------------------
Las rutas absolutas siempre empiezan por una barra / (que indica la raíz)

Si utilizo .. en una ruta estoy haciendo referencia al directorio padre. Un único punto indica el directorio actual

Linux distingue entre mayúsculas y minúsculas

Si quiero usar espacio en un nombre deberé ponerlo entre comillas o con un carácter de escape (\)

Usando los cursores arriba y abajo aparecerán las últimas ordenes que he ejecutado

Puedo ayudarme del tabulador para terminar de escribir una ruta

Con Control+R puedo buscar en el historial de instrucciones

El comando history  muestra el historial de instrucciones y puedo ejecutarlas usando !numero_instrucción 

El comando mkdir sirve para crear directorios

El comando rm borra ficheros, y con -r directorios

touch crea ficheros vacíos

mv mueve elementos o cambia su nombre

du muestra el espacio que ocupa un fichero o todo el contenido de un directorio

df nos informa del espacio libre y ocupado de las particiones del sistema

ln crea enlaces, débiles o fuertes.


--------------------------------------------------------------------------
comando sobre sistemas de fiheros 

• COMANDOS SOBRE EL USO DE DISCO 
‣ df (disk free): este comando nos da información sobre las particiones del sistema: 
tamaño total, usado y libre. Podemos usarlo sin opciones ni argumentos, pero la 
opción -h nos ayudará a entender mejor las cifras que se nos muestran.
Si le pasamos como parámetro cualquier directorio nos dará la información de la 
partición donde se encuentre ese directorio. 
VARIOS
• EJEMPLO:
‣ df -h /home/ 
Muestra en formato "humano" información sobre el espacio de la partición donde se 
encuentre /home/

• COMANDOS SOBRE EL USO DE DISCO 
‣ du (disk usage): muestra el espacio de disco ocupado por un fichero o por un 
directorio. Si le pasamos un directorio mostrará recursivamente el tamaño de 
todos los subdirectorios
Opciones: 
✓ -h : muestra el tamaño en KB, MB, etc.. 
✓ -s : si le pasamos un directorio muestra únicamente el total de lo que ocupa 
todo su contenido 
VARIOS
• EJEMPLO:
‣ du -hs /* 
Muestra en formato "humano" el total de lo que ocupan todos los elementos de la raíz del 
sistema




• ENLACES 
en linux cada fichero y carpeta tiene asignado un numero inodo (numero de identificcion o indice) se almacenan atributos, permisos , propietario,
localizacion en el disco duro, un enlace duro apunta al lugar en el disco duro en donde esta el contenido del archivo y el simbólico apunta al
 archivo en si(ruta). Un enlace simbolico es como los accesos directos en windows que estan en el escritorio, en realidad esos accesos no contienen
el programa ni el ejecutable del programa pero nos facilitan la vida teniendolos en el escritorio a tener todos los archivos o elejecutable
 de un programa ese acceso directo apunta a la rua en donde esta la carpet del programa en nuestro disco y luego el ejecutable ejecuta el programa
los permisos de los enlaces simbolicos empiezan con "l". si creamos un enlace duro y despues eliminamos el archivo original de donde hicimos el
 enlace el contenido de este estara intacto ya que tambien estará en el uevo archivo, sin embargo si eliminamos el archivo original al cual enlazamos
con un enlace  blando nos generará un error ya que ya no podremos accesar aese contenido por que no estabamos apuntando al contenido del archivo sino
 a su nombre (a su ruta), podemos crear un archivo con el mismo nombre y automaticamente se enlazara a el  
‣ ln: crea un enlace a un elemento del sistema de ficheros. Sin opciones creamos 
un enlace duro y con -s un enlace simbólico (o blando)
Un enlace duro es un puntero a la información de disco, mientras que uno 
blando apunta a la ruta 
A los directorios siempre se harán enlaces simbólicos
VARIOS
• EJEMPLOS:
‣ ln /etc/apt/sources.list ~/repos 
aqui /etc/apt/sources.list sera la ruta absoluta en donde se encuentra el contenido de nuestro archivo y   ~/repos  sera el enlace duro
Crea un enlace fuerte llamado repos que tendrá la misma información que el sources.list 
‣ ln -s /var/cache/apt/archives/ /paquetes/ 
aqui /var/cache/apt/archives/ es el archivo o directorio al que nos enlazaremos con un enlace blando llamado /paquetes/ 
Crea un enlace simbólico llamado paquetes, que irá a /var/cache/apt/archives/


cp  sirve para copiar ficheros  ejemplo:
cp  archivo_a_copiar.txt  archivo_que_recibira.txt si el archivo que recibira no existe lo crera, otro ejemplo
 cp  archivo_a_copiar.txt   directorio(carpeta que recibira) 
si queremos copiar una carpeta dentro de otra tenemos que usar el comando agregando un -r que indica que copiaremos un directorio 
(crearemos si no existe) ejemplo  cp -r carpeta_a_copiar  carpeta_destino
    se pueden copiar varios ficheros al mismo tiempo siendo el ultimo archivo el destino al que seran dirigidos 
    ejemplo:  cp  archivo_a_copiar.txt  archivo_a_copiar2.txt directorio(carpeta que recibira)


-comodin:  "*" usar asterisco nos sirve para seleccionar archivos en una carpeta, nos sirve para filtrar archivos y extenciones de tipo de archivo
    ejemplo podemos seleccionar archivos de un solo tipo de extencion com jpg poniendo *.jpg    y si por ejemplo queremos seleccionar 
    un tipo especifico de archivos que empiecen con el mismo nombre pero que terminen diferente por ejemplo: oficio_1.txt, oficio_2.txt etc
    ponemos oficio*    y seleccionaremos a todos los archivos de ombre oficio 

si queremos archivos que contengan una letra en especifico como aletra "a" ponemos *a*  y los buscara
si queremos buscar un archivo que comience con la letra "t" ponemos t*   y lo buscamos     
 

-comodin: "?" este coodin se usa cuando queremos especificar y filtrar el numero de caracteres de un archivo, por ejemplo:
si tenemos los archivos:
oficio_1.txt
oficio_3.txt
oficio_34.txt
oficio_123.txt
oficio_2.txt
            y ponemos:
ls-l oficio_?          aqui decimos que nos liste de forma detallada  un archivo llamado oficio_    y que tenga un solo caracter antes de
llegar a su extencion nos seleccionaria los archivos oficio_1.txt oficio_3.txt y oficio_2.txt
si pondemos  
ls-l oficio_??       aqui decimos que nos liste de forma detallada un archivo llamado oficio_   y que tenga dos caracteres antes de llegar a
su extencion nos seleccionaria el arhivo oficio_34.txt

-se pueden mezclar los dos comodines sin problemas por ejemplo :
ls -l oficio_??.*      aqui decimos que queremos un archivo llamado oficio  que contega dos caracteres antes de la extencion y que luego nos
 seleccione cualquier extencion   


+++++++++++++++++++Permisos en el sistema++++++++++++++++++++++++++
usamos la orden "su" si no especificamos el usuario nos redirigira directamente al usuario root. en ubuntu se suele utilizar "sudo"
nosotros en Debian podemos usar "sudo" para llamar al super usuario antes de dar una orden que requiera todos los permisos a la consola, pero
no podemos usar "sudo" para cambiar de usuario, especificamente para cambiar de usuario tenemos que usar "su" 
un usuario siempre pertenece a un grupo de forma principal pero puede pertenecer a otros grupos de forma secundaria 
al estar en root y presionar ls -l nos desplegará una lista en donde la primer columna de nombres es la del propietario del fichero y 
la segunda del grupo, ejemplo: Al poner el comando "ls -lh" podemos aprecia el siguiente desplegado de especificaciones de un archivo

  permisos   no. de enlaces en el archivo    usuario     grupo    tamaño del archivo      fecha    hora     nombre del archivo
-rwxrwxrwx               1                   root       root          1.34M              jun 2    22:35          file.txt


* exit uso este comando para salir de usuario root   
* whoami este comando te dice que usuario eres
* groups este comando te dira a que grupo perteneces  
* id la orden id te da informacion de un usuario, grupo principal y tus otros grupos 
* adduser este comando lo utilizamos para crear un usuario cuando estamos adentro de unusuario root ejemplo: adduser ana  y creamos el usuario ana 
le creamos una contraseña y la repetimos, no tenemos por que ir rellenando todos los dtos requeridos y vamos dando enter hasta terminar 
* addgroup   podemos crear  grupos con este comando ejemplo: addgroup alumnos      y crearemos el grupo alumnos, lo podremos utilizar como grupo 
principal o secundario
* usermod -g modifica el grupo principal de un usuario ejemplo: usermod -g alumnos ana      con esto estariamos diciendo que el grupo 
principal de ana seria alumnos lo podemos verificar con id 
*chown    podemos modificar el usuario y el grupo de de un sistema de ficheros  (tenemos que ser usuarios root) por ejemplo si tenemos un fichero 
(archivo) que es propiedad de un usuario en especifico, por ejemplo ana y con un grupo llamado alumnos  y quisieramos cambiar su usuario y
su grupo usariamos el comando: chown usuario_x_el_que_cambiamos:grupor_x_el_que_cambiamos noombre_del_fichero   
ejemplo: si le perteneciera al usuario ana con un grupo llamado users un archivo llamado  hola.txt y lo queremos cambiar a unusuario llamado
tux y a un grupo llamado alumnos, ponemos: chown tux:alumnos hola.txt
esto tambien se puede hacer de forma independiente osea cambiando solo un usuario o solo el grupo. para cambiar solo el usuario se hace 
chown nuevo_propietario fichero.txt por ejemplo sicambiaramos de usuario ana a tux: chown tux hola.txt
-para cambiar el grupo solo se ponen dos puntos antes del nuevo ombre del grupo por ejemplo: chown :alumnos hola.txt

*passwd usamos este comando para cambiar la contrasea de un usuario: passwd usuario        con esto cambiamos la contraseña del usuario
seleccionado en caso de no especificar un usuario se cambiaria por default la contraseña de usuario que esta poniendo este comando 


los permisos del sistema se dividen en 4 tipos

tipo de fichero=1, usuario=2, grupo=3 y otros=4 

1  2   3   4
- rw- r-- r--
- rwx rwx rwx
d rwx r-x r-x


r significa que tenemos concedido el permiso de lectura
w significa que tenemos concedido el permiso de escritura
x significa que podemos ejecutar ese fichero

los permisos siempre se dividen en 4 partes, la primera nos dice que tipo de archivo es,los segundo  los permisos que tiene el
 usuario, el tercero los que tiene el grupo
y por ultimo el resto de usuarios . El orden de importancia y de ordenacion siempre sera r primero luego w y al ultimo x,  ejemplo:
-rw-rw-rw- aqui tenemos los tres bloques con dos permisos par cada bloque 


*directorios:dependen con que caracter empiecen los permisos del sistema, indicara que tipo de sistema de ficheros son , si empiezan con
una "d" significa que es un directorio, si tiene una "l"es un enlace y si tiene un guion "-" significa que es un fichero regular.    
complementario si aparece una "r" en un directorio significa: listar, eso significa que se desplegaran los archivos del folder 
ejemplo: dr-xr-xr-x      en estos permisos estamos trabajando con un directorio por que tiene 4 grupos de carcateres y empieza con la letra d
                         y nos podra mostrar la lista de archivos al poner el comando ls -l ya que tiene una "r" al lado de la "d" 
si entramos a un directorio en donde no tiene el permiso "W" que seria el de poder crear o borrar un documento, entonces no podriamos
afectar a ningun documento dentro de el (borrar o crear) pero si podriamos editar el contenido de losdocumentos si estos
tienen esos permisos. X significa que podemos entrar y ver los archivos de una carpeta 
r significa listar elementosde un directorio (poder los archivos disponibles en una carpeta)
w significa el poder crear o eliminar archivos en un directorio
x significa el poder entrar al directorio   

*chmod otorgar o quitar permisos, estos permisos se daran a los 3 grupos usuarios, grupos y demás
primera forma:
 ESTRUCTURA: chmod +letra_de_permiso_a_otorgar archivo.txt          ejemplo:     chmod +r hola.txt
       aqui le otorgamos el permiso de lectura a "u","g" y "o" del archivo hola.txt 
para quitar permiso la estructura es: chmod -letra_de_permiso_a_otorgar archivo.txt                 ejemplo:     chmod -r hola.txt
aqui le quitamos el permiso de lectura a "u","g" y "o" del archivo hola.txt  


si queremos quitar especificamente un permiso los tres grupos se especificaran con la letra u-g-o   siendo "a" para todos, "u" el del propietario, "g" los grupos
y "o" los demás estructura  chmod u+letra_de_permiso_a_otorgar archivo.txt          ejemplo:     chmod u+r hola.txt
aqui le dimos el permiso de lectura solo al promietario, podriamos dar o quitar varios permisos especificos a la vez ejemplo: chmod g+r,o+r hola.txt
aqui le dimos permiso de lecturaa los grupos y a los otros separndo con una coma.

segunda forma:
otra forma de dar permisos especificos es igualando el usuario especifico al permiso que le otorgaremos pero quedaran descartados cualquier otro
permiso que no especifiquemos.
ejemplo: chmod u=r,g=w,o=r hola.txt
esto nos dira que el usuario propietario solo tendra el permiso de lectura y todos los demas permisos estan descartados y asi con los demás 
si quieremos quitarle los permisos a todos ponemos: chmod u=,g=,o= hola.txt    
si quieremos darle los permisos a todos ponemos: chmod u=rwx,g=rwx,o=rwx hola.txt 


tercera forma: se expresa en binario de cierta manera es mas facil de entender , recordar siempre que 2^0=1,
               2^1=2, 2^2=4 en donde r=2^2=4, w= 2^1=2 y x=2^0=1. Por lo tanto si vemos:

               R|W|X| R|W|X| R|W|X|
               1|1|1| 0|0|1| 1|1|0|
                 7       1     6    
               con 716 le estariamos diciendo que el usuario tiene todos los permisos, que el grupo tiene solo el permiso de ejeciucion y que los otros
               solotiene permiso de lectura y escritura. podriamos poner 777 y dar todos los permisos a todos los apartados
o podriamos poner  000 y quitar todos los permisos de todos los apartados.



+++++++++++++++++++++++++++++++++++++++++++++Busquedas en los sistemas de ficheros ++++++++++++++++++++++++++
*find  con este comando podemos hacer una busqueda en una ruta determinada y con especificos parametros de busqueda
o con tipos de parametros(directorios,ficheros,enlaces simbolicos,dispositivos de bloque dispositivos de caracter ó sockets). 
la estructura de busqueda seria: find ruta_especificada -name/-iname "opciones"  -type
en las obciones siempre irá la palabra -name para distinguir entre mayusculas o minusculas ó -iname si no quieres que
distinga entre minusculas o mayusculas.
Direccion de ruta actual ".", direccion de ruta anterior ".."

tipos:
d=directorios,f=ficheros,l=enlaces simbolicos,b=dispositivos de bloque,c= dispositivos de caracter y s= sockets 


ejemplo: find .   -iname "*.mp3"
         En este ejemplo ponemos el comando find luego la ruta, en este caso ponemos un punto "." ya que 
         un punto representa que trabajaremos con archivos que estan en el, luego ponemos -iname por que no queremos
         considerar la diferencia entre minusculas y mayusculas al buscar el archivo y por ultimo especificamos 
         un tipo a buscar , que en este caso es que sea de tipo .mp3 eso lo especificamos entre comillas.  
 
ejemplo: find .   -iname "*i*.mp3"
         En este ejemplo ponemos el comando find luego la ruta, en este caso ponemos un punto "." ya que 
         un punto representa que trabajaremos con archivos que estan en el, luego ponemos -iname por que no queremos
         considerar la diferencia entre minusculas y mayusculas al buscar el archivo y por ultimo especificamos 
         un tipo a buscar , que en este caso es que tenga una letra "i" en cualquier parte del nombre y que sea de 
         tipo .mp3 eso lo especificamos entre comillas.  

ejemplo: find .   -iname "*i*" -type f
         En este ejemplo ponemos el comando find luego la ruta, en este caso ponemos un punto "." ya que 
         un punto representa que trabajaremos con archivos que estan en el, luego ponemos -iname por que no queremos
         considerar la diferencia entre minusculas y mayusculas al buscar el archivo y por ultimo especificamos 
         un tipo a buscar , que en este caso es que tenga una letra "i" en cualquier parte del nombre y de tipo file 
        (folder).  
ejemplo: find / -name "*.txt"
         En este ejemplo usamos un slahs "/" esto le indicara al comando que debe buscar cualquier archivo definido a
         buscar en el sistema independientementre de la carpeta.       
 
Más opciones:    
-size +/-<n> permite indicar el tamaño máximo y/o mínimo de los ficheros a buscar. Por defecto el tamaño se expresa en
 bloques de 512 bytes, pero se puede especificar las magnitudes por un carcater: c se referirá a bytes, k a kilobytes,
 M a megabytes y G a gigabytes.


 ejemplo: -size +2M
          aqui buscara archivos que ocupen espacios que pesen más de dos megas 
          -size +2G
          aqui buscara archivos que ocupen espacios que pesen más de dos gigas }

opcion permisos:
-perm nosotros usamos este comando para especificar que queremos un archivo que cumpla con permisos especificos
(expresados de manera binaria), si ponemos "-"  nos referiremos a permisos activos y / a permisos obcionales  
ejemplo de archivos disponibles: 

-rw-rw-r--
-rw-------
-r--------
      
ejemplo:   find -perm 600
           en este caso nos buscara un archivo que tenga especificamente solo los siguientes permisos en "u": -rw-------

ejemplo:   find -perm -600
           en este caso nos buscara archivos que contengan activos los permisos seleccionados tanto en "u" como en "u" y en "o"
                         -rw-rw-r--
                         -rw-------  
ejemplo:   find -perm /600 
           en este caso decimos que si un archivo tiene activo cualquiera de los permisos establecidos lo vamos
           a seleccionar, ya que todos tienen al menos uno activo seleccionamos todos:
                         -rw-rw-r--
                         -rw-------
                         -r--------
opcion usuarios:
-user <usuario> especifica el usuario propietario del fichero
-group <usuario>especifica el grupo propietario del fichero         

ejemplo: -user root 
         aqui vere todos los archivos del usuario root  
ejemplo: -group root 
         aqui veremos los archivos del grupo root
EJEMPLO: find -user alumno -group


opcion fecha de modificación
-mmin [+/-]n los datos que proporcionemos a lado del signo mas o menos especificaran minutos transcurridos antes
      o despues de modificar un archivo.
-mtime [+/-]n los datos proporfionado despues de mtime nos dira los dias que han pasado despuesde la modificacion de
       un documento. 


opcion especificacion de niveles en los que deciende en una carpeta para buscar un documento:
-maxdepth <niveles> Desciende una cantidad determinada de niveles en una carpeta buscando un archivo si le pongo
                    -maxdepth 1  solo buscará en el directorio actual.
EJEMPLO: find -maxdepth 4 -iname "*a*"
         en este comando decendemos 4 niveles del directorio actual y buscamos un archivo que contenga la letra "a" 
          sin importar si es mayuscula o minuscula 


                                                     exec 


opcion ejecutar comandos en los elementos de fine:
-exec <comando>;es una tuberia exclusiva del find permite definir un comando a ejecutarse para cada
resultado de la busqueda. La cadena {} se sustituye por el nombre de los ficheros encotrados.
El caracter ; permite indicar la finalización del comando. (Tanto {} como ; tienen
que entre comillas o entre contrabarras para evitar que sea sustituidopor el shell)

todos los archivos encontrados por el find quedaran guardados en las llaves, al iniciar el exec 
pondremos la accion que queremos hacer despues irtan las llaves, con esto indicamos
que la accion que queremos afectara a todo lo que se encuentre en las llaves y despues ponemos los dos puntos
que indicara que termionamos el comando.
ejemplo:
find . -name "pescando*" -exec mv "{}" lubina.jpg ";"
aqui decimos que apartir de la carpeta actual nos busque el archivo "pescando*" y despues de encontrarlo
con exec realice otra accion en este caso cambiarle el nombre con el comando "mv" diciendole
que el archivo encontrado en el find y que esta almacenado le cambiaremos el nombre y despues con los dos puntos 
indicaremos que ya acabamos.  

ejemplo: 
find /etc/ -iname "*.conf" -scd
ize -1M -exec cp "{}" /home/copias/ ";"
con este comando buscamos en la carpeta etc un archivo que pese menos de un mega, sin importar si su nombre tiene
mayusculas o minúsculas, detipo .conf, después ocuparemos el comando exec para mover el o los archivos en la 
ruta especificada (el o los archivos seran represntados por las llaves) y al final establecemos que hemos
terminado el comando con ";". Notael comando exec siempre suele ir al final.

ejemplo: 
find ~ -size +2G -exec rm "{}" ";" 
con este comando buscamos en el directorio home (~) un archivo con tamaño mayor a 2G y con el comando exec todos
los archivos encontrados con esa condicion sera borrado

filtro grep:
grep palabra_a_buscar   este filtro se ocupa principalmete para filtrar nombres de archivos dentro de un directorio 
y buscar uno que contega una palabra en específico


ejemplo: 
find documentos/ -type f -exec grep -l informe "{}" ";" 
aqui buscamos un archivo en la carpeta documentos de tipo file (carpeta) y usamos el comando exec para filtar
la busqueda a una carpeta o carpetas con el nombre informe y ponemos -l para que os desu diereccion

ejemplo:
find -size +50M -exec ls -lh "{}" ";"
aqui buscamos un archivo de masde 50 Megas y con el comando execespecificamos que todos los archivos que encontremos
con estas especificaciones los listemos y nos muestren sus especificaciones y poder visualizar sus tamaños 
de tipo humano



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Filtrar texto+++++++++++++++++++++++++++++++++++++++++
echo: muestra el texto que recibe, con -e interpreta los caracteres especiales como \n que seria un salto de linea
si no se pone -e echo imprimira en pantalla incluso \n
ejemplo: echo "esto es \n un ejemplo"       imprime:esto es \n un ejemplo

ejemplo:echo -e "esto es \n un ejemplo"       imprime:esto es
                                                       un ejemplo



cat : muestra  el contenido de un archivoy puede concatenar ficheros de texto.  usamos -n para ver el numero
de lineas en el archivo


more: este comando Nos divide la visualizacion de un archivo por pantallas, como si fuera un libro, con la 
tecla espaciadora nos va pasando las pantallas asta llegar al final del documento, con la tecla "q" salimos del modo 
more y con la tecla h nos despliega un menu que nos muestra los comandos dentro de more 1010  20   


less: de principo hace lo mismo que more y con las mismas teclas pero te limpia la pantalla al salir y esta optimizado 
para ficheros de muchas lineas, es mas eficiete y rapido que more. Podemos teclear la cantidad de lines que quermos 
avanzar  


head: este comando nos sirve para ver solo las primeras lineas de un archivo, por defecto son 10
si queremos  especificar el numero de lineas a ver ponemos: head -nnumero_de_lineas
ejemplo, si queremos ver las primeras 23 lineas ponemos: head -n23  
o tambien siempre podemos usar los comodines * y ?
ejemplo:  Head -n5 *.log
aqui le decimos que nos busque las primeras 5 lineas de todos los ficheros que terminen con .log


tail: nos sirve para ver las ultimas lineas de un archivo,por defecto son 10  
ejemplo, si queremos ver las ultimas 20 lineas de un archivo:
tail -n20 /direccion




cut 
corta una parte especificada de una linea, mostrando solo una parte de la linea, usa el parametro "-c"
el cual nos ayuda a especificar los caracteres que queremos seleccionar y los demás los borrará. 
Se pueden utilizar números indepentientes separados
por comas o dos números separados por guion para indicar el inincio y el fin de un rango. Si algo no está 
presente se entiende que será el inicio o el fin de linea. el parametro -d funciona como un caracter separador  entre
los diferentes campos de una linea, ya que al imprimir el corte en pantalla siempre aparecera todo
concatenado y la separacionentre un tipo de informacion y otra se señala con ":"  y con el parametro -d 
podremos separar cada rango o caracter especifico.  el parametro -f 
elige las columnas que queremosque se muestren. la forma de selecccionar funciona igual que para la opcion -c  

ejemplo:
cut -c5 file .txt
solo nos mostrara el carcter 5 
 
ejemplo: cut -c 5,10 file.txt 
aqui le decimos que nos seleccione el carcater 5 y el 10, solo seleccionariamos 2 caracteres el 5 y el 10   



ejemplo: cut -c 7,25 file.txt
aqui le decimos que nos seleccione el carcater 7 y el 25, solo seleccionariamos 2 caracteres el 5 y el 10 


ejemplo: cut -c1 file.txt
aqui le decimos que nosmuestre el primer caracter de cada line del archivo file.txt

ejemplo: cut -c1-10 file.txt
aqui le decios que nosmuestre desde el primer caracter hasa el numero 10

ejemplo: cut -c8-15 file.txt
aqui le decios que nosmuestre desde el octavo caracter hasa el numero 15
     

podemos mezclar la busqueda de caraceres especificos y de rangos
ejemplo: 
cut -c1-3,10-15,25 file.txt 
aqui le decimos que queremos elrango de 1 al 3 del 10 al 15 y el caracter 25

ejemplo :
cut -d":" -f1 file.txt 
aqui -d nos indica que se cortarán todas las lineas hasta que encuentre ":"
(por que -d actua como delimitador y le estamos estableciendo que el limite sean 
los dos puntos ":")  y con -f1 que solo semostrara en pantalla la columna 1  




grep
este comando nos sirve para mosrar las lineas que cumplen un patrón. se puede
usar para palabras o expresiones regulares, por si solo solo buscara que haya coincidencia
con la letra o palabra buscar pero eso nos puede dejar muchas opciones para eso necesitamos 
parametros de busqueda: La opcion "-v" muestra las que no
coinciden con el patron, "-l" no nos indica la linea en donde esta la palabra buscada, solo indica
el nombre del fichero donde ha encontrado 
alguna coincidencia, "-w" el patron tiene que ser una palabra independiente osea 
que la palabra o letra tiene que ser especifica y no forma parte de otra palabra o 
este concatenada con otra letra,"-n"nos 
indica el numero de la linea en donde ha encontrado la palabra, "-i" no distingue entre mayusculas
 y minusculas, "-c"
muestra la cantidad de lineas que cumplen con el patron, "-r" busca en los ficheros
de forma recursiva(no solo busca en un directorio, tambien busca en los
directorios de los directorios).   


grep 100 /etc/passwd
este cmando nosdira que busque el 100 en passwd y gred nos arrojara todoslos numeros
que tengan 100 al inicio o final o que sean exactos
100000
1010100
100          <--este seria el unicoq que nos interesa

grep -w 100 /etc/passwd   
este comando a diferencia del anterior solo nos seleccionara la opcion 100

grep ^a /etc/passwd
este comando nos mostraralas palabras queempiezan con a 


++++++++++++++++++++++++++++++++++++++Editor de texto por consola+++++++++++++++++++++++++++++++++

editor: nano

para trabajar con el editor nano solo debemos poner "nano"  en la consola y nos abrira el editor de texto.
ejemlo: nano _archivo_a_crear_o_a_abrir

en el menun de trabajo nos indica que tenemos que mantener oprimida la tecla control cuando vemos "^"
o pulsar dos veces seguidas la tecla escape, mientras que la M indica que tenemos que pulsar una sola vez la tecla scape 
antes de la letra del menu que escojamos.
podemos usar control +k y copiar una linea y control + u para pegar , usar el corrector ortográfico con control +T 


Editor: Vin
usamos el comando: vi _nombre_del_fichero 
con control +v  corta una linea y co control p la pega
si queremos buscar una palabra ponemos "/" y la palabra a buscar pegado de la barra 
si queremos escribir usamos la tecla "i" cuando terminemos usamos la tecla scape 
linea de ordenes: pulsamos ":" aqui damos ordenes que queremos hacer como salir del programa, guardar etc si
queremos salir sin guardar cambios ponemos ":q!"  
con ":q" salimos 
con ":w" guardamos 
con "dd" salimos de modo insercion
Vi es el primer editor de texto para la consola de Linux. Es importante
conocerlo porque está en TODAS las distribuciones y modos de arranque.
Actualmente es más común usar Vim (vi mejorado) que el Vi original.
Tiene tres modos de funcionamiento:
• MODO COMANDO
cuando entramos a modo comando no hay necesidad de poner ":" antes de un comandoso
Se empieza en este modo, siempre podemos volver a él pulsando la tecla ESC.
Podemos realizar acciones pulsando una o varias teclas
Acciones en el modo comandos:
‣ Con los cursores o las teclas h,j,k,l nos desplazamos por el texto
‣ dd borra una linea, yy copia y p pega
‣ o añade una nueva linea, u deshacer la última acción
‣ /palabra realiza una búsqueda hacia abajo, ?palabra busca hacia arriba
‣ i inserta texto antes del cursor, a después del cursor
‣ ZZ guarda el documento y sale
‣ v selección visual de texto  
• MODO INSERTAR
Podemos insertar texto con normalidad.
• MODO EX
 Para acceder al modo ex pulsamos los dos puntos y a continuación ponemos la
acción a realizar.
‣ q salir, w escribir el fichero. Se pueden combinar como :wq
‣ Se puede usar la ! para forzar una acción, como salir sin guardar. :q!




Sort: este comando nos ayuda a organizar nuestro archivo de texto o listado de archivos, nos ordenara
alfabeticamente por defecto  
sort -r ordena en orden inverso
sort -n ordena de forma numerica
sort -h ordena por tamaño y muestra los datos en formato humano 
ejemplo:
ordenar el fichero /etc/passwd en funcion de los nombres de usuario. hazlo tambien de manera inversa
sudo sort -r /etc/passwd | cut -d":" -f1

Uniq: ete comando quita archivos repetidos al listar o ver un archivo quita las lineas repetidas
si tenemos 
ana
ana
eduardo
julian
tulio
juan
juan
ana

nos dejara solo 
ana
eduardo
julian
tulio
juan
ana

de modo que quita los repetidos que esten juntos pero los separados los deja
sus opciones: -d muestra solo las lineas repetidas, -i ignora si es mayusculao minuscula y la -c que muestra as cantidad de
veces que se repite una linea 



wc: 
este comando nos dique la cantidad de linas, palabras y caracteres en un listado de archivos
o en un documento, si no le damos ningún parametro nos drá los tres datos por defecto. Sus carcateres son:
-l para lineas, -w para palabras y -m para caracteres. Ejemplo:
wc -l /etc/passwd    aqui solo nos mostrara el numeo de filas de un archivo
wc -m /etc/passwd    aqui solo nos mostrara el numerode caracteres 
   

rev: 
este comando le da la vuelta al texto que estamos leyendo, lo pone como silo estuvieramos leyendo de
derecha a izquierda, esto nos sirve si queremos ordenar una direccion y queremos quedaros
solo con el ultimo destino y nos lo posicione al principio .
ejemplo, tenemos: /etc/perl/net
y queremos solo la direccion net entoces usamos el comando rev y hacemos uso del comando cut
rev file.txt | cut-d "/" -f3 | rev
con el comando rev ivertimos la linea y teemos:
ten/lrep/cte/
y luego con el comando cut tenemos que -d nos dice que "/" marcará la separacion de un campo
y -f3 que solo nos muestre el campo 3 , por lo tanto solo vemos:
ten/   
al final volvemos a poner "rev" y nos pone el directorio de forma completamente legible de nuevo:
/net



++++++++++++++++++++++++++++++++++++++++redirecciones +++++++++++++++++++++++++++++++++++++++++++++++++++
podria decirse que hay dos direcciones disponibles, la primera es hacer que un comando de una accion correcta 
y se muestre por pantalla y la otra que el usuario escriba un comando que   no se vea en panatalla pero 
genere una accion en un archivo y en este ultima se deriva en dos partes, la primera es cuando se cumple
la accion sin ningun error y la segunda cuando se genera un error, a estas seles asignaran respectivamente 
el nunmero 1 y 2. La segunda nos sirve especialmente para cuando registramos un error en n comando 
y la consola nos muestra todo lo que esta mal y este contenido lo podemos almacenar en un archivo usando el numero
2 antes de la direccion: 2>    y si queremos guardar los datos expresados por consola
tamto de 1 y 2 ponemos:  &>  
 

• Usando un solo > si el fichero existe, lo sobrescribe, si no existe lo crea
• Usando dos >> si existe añade el texto al final
• Los mensajes de error se pueden redirigir de forma independiente usando 2> o 2>>
• Para redirigir todos los mensajes se usa &> o &>>

+++++++++++++++++++++++++++++++++++++++tuberias+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Además de enviar texto a un dispositivo,
disponemos de otra potente opción: enviarlo a
otro comando. Esto se realiza con el carácter "|"
Recibe el nombre de tubería, ya que establece un
“canal” por el que pasará el texto de un comando a otro
ejemplo:
echo “HOLA MUNDO” | wc

aqui diremos queimprimiremos un las palabras "hola mundo" con el comando "echo" pero ese resultado lo enviaremos por una "tuberia"
hasta el comando "wc" el cual nos dira lasespecificaciones (cantidad de lineas, palabras y caracteres) que hay en el mensaje enviado

grep -w ana /etc/passwd | cut -d”:” -f1 | sort

el comando "grep -w" nos dira que buscara unapalabra especifica (ana) en un archivo con la direccion  /etc/passwd
el resultado nos lo enviara por una tuveria en donde cortaremos la linea en donde encotramos la palabra ana en donde 
encontremos el parametro ":" y nos imprimira la primera columna del archivo y ese resultado lo enviaremos por
una tuberia al comando sort que ordenara las columnas de mayor a menor  

•También se puede redirigir la entrada de texto, para ello usamos el carácter <, que
enviará la información que lee de un fichero al comando.
sort < listado
mysql < db_backup.sql
• Si queremos desechar alguna salida, podemos usar el dispositivo /dev/null. Enviar texto
hará que no aparezca ni se guarde en ningún sitio
grep -r max_size /etc/* &> /dev/null
• Podemos combinar todo lo estudiando en este tema
 wc /etc/a* 2> /dev/null | sort -n > count




++++++++++++++++++++++++++++++++++++++++++++++++++++++Comando TR+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Usaremos este comando para usos más avanzados como el redireccionamiento y los patrones de texto, lo que hace
es reemplazar o eliminar caracteres quelee desde la entrada estandar. Ejemplo: vamos a sustiruir la letra "a" por la "e"

comando: tr a e
nos pedirá escribir una palabra y podremos escribir la palabra "casa"  y la consola nos imprimirá la palabra cese   
salimos del comando con "control + c".



ejemplo: si guardamos la palabra casa en un fichero y luego lo ejecutamos con el comando "tr" veremos las sustitucione que
podemos hacer.

echo casa > fichero.txt
tr ac en < fichero.txt

imprime: nese 


como vemos la "a" la sustituye por "e" y la "c" la sustituye por "n"  y hay que tener mucho cuidado cuando
quitamos carcateres de un archivo o podemos usar el tr y ponerleparametros y luego asignarle un archivo
hay que ponerle una redireccion estandar ">" al archivo de texto en donde lo queremos ejecutar

Rangos: podemos usar TR para poner rangos de letras 

• RANGOS: caracter_inicio-caracter_final
 a-z incluye todas las minúsculas
 d-g incluye las letras defg

• REPETICIONES: [caracter*numero]
 [a*3] indica la cadena aaa

• CARACTERES ESPECIALES

\\ : Barra invertida.
\a : Caracter audible (Campana/Bell).
\b : Retroceso.
\f : Salto de Pagina.
\n : Nueva línea.
\r : Retorno de carro.
\t : Tabulador.
\v : Tabulador vertical. 

• CLASES: representan un conjunto predefinido de caracteres

[:alnum:] : Las letras y Dígitos
[:alpha:] : Letras
[:blank:] : Espacios en Blanco
[:cntrl:] : Caracteres de control
[:space:] : Los Espacios en Blanco verticales y horizontales
[:graph:] : Caracteres imprimibles, sin incluir el Espacio en Blanco
[:print:] : Caracteres imprimibles, incluyendo el Espacio en Blanco
[:digit:] : Dígitos
[:lower:] : Letras minúsculas.
[:upper:] : Letras mayúsculas.
[:punct:] : Signos de puntuación.
[:xdigit:] : Dígitos Hexadecimales.
  

Ejemplo usando clases:

comando:echo "esto es una frase, con varias palabras por ejemplo 15" > fichero.txt
comando para imprimir:tr [:digit:] X < fichero.txt

imprime: esto e sua frase, co varias palabras por ejemplo XX


Ejemplo usando clases:

comando:echo "esto es una frase, con varias palabras por ejemplo 15" > fichero.txt
comando para imprimir:tr [:alpha:] X < fichero.txt

imprime: XXXX XX XXX XXXXX, XXX XXXXXX XXXXXXXX XXX XXXXXXX 15


Ejemplo usando clases:

comando:echo "esto es una frase, con varias palabras por ejemplo 15" > fichero.txt
comando para imprimir:tr [:space:] - < fichero.txt

imprime:esto-es-una-frase,-con-varias-palabras-por-ejemplo-15

Opciones en "tr": -d le inndicamo que borre el cojunto de caracteres quele especificamos,+++++++++++++++++++++++++++++++++++++
-s elimina los caracteres repetidos en una palabra, -c se veran afectados todos los caracteres
menos los que especificamos.


Ejemplo:
c
resultado:
-rwxrwxrwx   1    root    root    1.34M   jun 2    22:33    file.txt   


si nosotros queremos ver columna por columna ponemos: 
ls -lh . | cut-d" " -f4
aqui decimos que queremos ver la columa 4 perooooo muchas veces en el nombre de usuarios
tiene demasiados espacios y el cut no detecta correctamente el nombre, entoces usamos el 
tr -s  y eliminamos losespacios repetidos y asi pueda funcionar correctamente el cut e
imprimir correctamente la columna.

ls -lh . | tr -s " " | cut-d" " -f4

con este comando le decimsoq ue nos enliste en formato humano los archivos en e directorio actual
que borre los espacios repetidos y que defina cada espacio como separacion de columnas y que al final
nos uestre la columna 4 

  
 ejemplo:
si queremoseliminar toda las vocales podemos usar el comando -d
comando para imprimir: tr -d aeiou < file.txt  
 eliminaremos todas las vocales de ese texto   

ejemplo :
si queremos pasar los caracteres de un texto de minuscula a mayuscula ponemos:
comando para imprimir:tr [:lower:] [:upper:] < file.txt





Sed

es un editor de flujo de texto:
• SINTAXIS: sed [-n] [-e'script'] [-f archivo] archivo1 archivo2
• -n indica que se suprima la salida estándar.
• -e indica que se ejecute el script que viene a continuación.
Si no se emplea la opción -f se puede omitir -e.
• -f indica que las órdenes se tomarán de un archivo
• -r se utilizan expresiones regulares EXTENDIDAS

• Comando de ejemplo:
sed '2,5p' texto.txt

• Sintaxis del script :
     [ inicio_ubicacion [,fin_ubicacion]] instrucción [argumentos]
 sed         '2,               5                p'      texto.txt

con este comandoprimero ponemos "sed" luego el punto de inicio del comando en el documento que seria en la 
linea 2 y terminaria en la linea 5 haciendo una accion "p" (Imprimir línea actual en salida estándar.)

• UBICACIÓN (Si no es especifica se verán afectadas todas las lineas)
Se puede indicar de dos formas

1. Mediante números: Especificamos los números de linea de principio y fin.
("$" significa la última línea)
2. Mediante patrones de texto: son las líneas que cumplen con la expresión regular
especificada /EXPRESIÓN/

Utilizando cualquiera de estos métodos, se pueden aplicar rangos, indicando el inicio y
fin separados por comas:

COMANDO SED (ningna indicacion en sed se guarda en el archivo final, este comando solo nos sirve para
visualizacion)

‣ 1,5 => de la linea 1 a la 5
‣ /pepe/,$ => desde linea la que contiene la
palabra pepe hasta la última

• i\ = Insertar línea antes de la línea actual.
• a\ = Insertar línea después de la línea actual.
• c\ = Sustituye la línea actual por la especificada a continuación.
• d = Borrar línea actual.
• p = Imprimir línea actual en salida estándar.
• s = Sustituir cadena en línea actual.
• ! = Aplicar instrucción a las líneas no seleccionadas por la condición.
• q = Abandona el proceso cuando se alcanza la línea especificada.


ejemplo:

sed -e "/palabra_a_buscar/d" file.txt

aqui buscamos una palabra y borramos la linea en donde se encuentre



ejemplo:



sed -e "/palabra_a_buscar/,10d" file.txt

aqui buscamos una palabra ubicandola como una primera ubicacion y luego le decimos que la linea 10
será la ultima ubicacion y que aplique el parametro "d" y esto borrará la linea en donde se encuentre
la palabra buscar hasta la linea 10 del archivo file


ejemplo:

cat -n file.txt | sed -e "/palabra_a_buscar/,10d" file.txt

aqui nos numera las lineas con el comando cat y luego por medio de una tuberia usamos el comando sed
buscamos una palabra ubicandolacomo una primera ubicacion y luego le decimos que la linea 10
será la ultima ubicacion y que aplique el parametro "d" y esto borrará la linea en donde se encuentre
la palabra buscar hasta la linea 10 del archivo file

ejemplo:

sed -e "1a\HOLA" file.txt

este ejmplo nos dice que la fila 1 será nuestro punto inicial y usara la instruccion "a" Insertar línea
después de la línea actual,  entonces nos imprimirá la palabra "HOLA" en la segunda linea del archivo
file.txt 

ejemplo:

sed -e "1i\HOLA" file.txt

este ejmplo nos dice que la fila 1 será nuestro punto inicial y usara la instruccion "i" Insertar línea
antes de la línea actual,  entonces nos imprimirá la palabra "HOLA" en la una linea antes dela
linea en la que estamos convirtiendo asi nuestra linea 1 en la linea 2 e imprimiento la palabra hola
en la linea 1 en el archivo file.txt 

ejemplo:

sed -e "1c\HOLA" file.txt

este ejmplo nos dice que la fila 1 será nuestro punto inicial y usara la instruccion "c" reemplazando la linea
indicada por la palabra "HOLA" en el archivo file.txt 

ejemplo:

sed -e "2p" file.txt

este ejmplo nos dice que al principio del documento nos mostrará la fila 2 y despues empezara todo el texto del archivo
file.txt 
si queremos que solo nos muestre la linea seleccionada y omita la salida estándar (la vista de todo el documento)
agregamos el paraetro "-n" al principio del comando. ejemplo:
sed -n -e "2p" file.txt
esto solo nos mostrara la fila 2 y la vista de todo el documento será omitida


ejemplo:

sed -n -e "1,3p" file.txt

esto nos muestra unicamente las primeras tres lineas del documento


ejemplo:

sed -n -e "1,3!p" file.txt

utilizando el parametro "!" nos muestra todo el documento unicamente sin las primeras tres lineas del documento


ejemplo: 

sed -e "5a\FRASE" -e "7i\FRASE" file.txt

aqui llegamos a la quinta fila e insertamos la palabra "FRASE" despues de la quinta linea, dejando la palabra
FRASE en la sexta fila, luego pasamos a la septima fila e insertamos la palabra "FRASE" una linea antes de la septima
linea  


ejemplo:

sed -e "/Frisaba/q" -e "/y/c\VACIO" file.txt
 
este comandova abuscar la palabra "Frisaba" por todo el documento y cuando la encuntre lo dejara de ejecutar
(mostraralas lineas del documento hasta que encuentre la palabra indicada parará) luego 
cada que encuentre la letra "y" usarael parametro "c" borrara el contenido de es linea y la sustituira por la palabra "VACIO"
en el documento file.txt



Nota: en "sed" podemos usar las "Clases" que ocupamos en el comando "tr"

ejemplo: 

sed -e "s/[[:upper:]]/X/" file.txt

aqui le decimos quecon el parametro "s" nos sustituya un caracter  especificado, pero solo nos sustituira
este caracter si es el primero de la linea 
en este caso le decimos que todas las letras mayusculas utilizando el comando [:upper:] las cambien a X en
el documento file.txt 

ejemplo: 

sed -e "s/[[:upper:]]/X/g" file.txt

aqui le decimos que con el parametro "s" nos sustituya un caracter  especificado, en este caso agregando la "g"
nos sustituira todos los caracteres de cada inea que cumpla con la especificacion
en este caso le decimos que todas las letras mayusculas utilizando el comando [:upper:] las cambien a X en
el documento file.txt 

ejemplo: 

sed -i -e "s/[[:upper:]]/X/g" file.txt

aqui le decimos que todos las ordenes de este comando set sean guardadas en el archivo original con el parámetro "-i"
con el parametro "s" nos sustituya un caracter  especificado, en este caso agregando la "g"
nos sustituira todos los caracteres de cada inea que cumpla con la especificacion
en este caso le decimos que todas las letras mayusculas utilizando el comando [:upper:] las cambien a X en
el documento file.txt 



++++++++++++++++++++++++++++++++++++++++++++++++++++Expresiones regulares ++++++++++++++++++++++++++++++++++++++++++++++
• CARACTERES ESPECIALES
‣ ^ (acento circunflejo): Inicio de linea esto nos ayuda a buscar palabras que empiecen forsozamente con la letra especificada
‣ $: Fin de línea
‣ . :cualquier carácter. Si queremos quitar el significado especial tendremos que
poner la contrabarra \ delante
• CORCHETES []
‣ Se usan para indicar que en una posición determinada pueden aparecer un
conjunto determinado de caracteres. Por ejemplo [aeiou] significa donde se
encuentre puede haber cualquier vocal minúscula.
‣ Ejemplo: c[aei]s[ao] =>

aqui le decimos que busque palabras que forzosamente comiencen con la letra "c" utilizando "^", que opcional mente
el siguiente carcater sea una a, e ó i despues que la siguiente linea forsozamente sea una "s" y la última linea
se opcionalmente una a ú o y utilizamos $. 
grep ^c[aei]s[ao]$ /usr/share/dict/spanish 

podriamos tener las siguientes opciones pero solo algunas cumplen la condicion 
casa...bien 
cese...mal
caso...bien 
ceso...bien
casi...mal




ejemplo 1:
grep ^a /usr/share/dict/spanish | tail

aqui le decimos que nos busque las ultimas 10 palabras de un diccionario encontrado en esa direccion
que comiencen con la letra "a"




ejemplo 2:
grep o$ /usr/share/dict/spanish | tail

aqui le decimos que nos busque las ultimas 10 palabras de un diccionario encontrado en esa direccion
que terminen con la letra "o"



• CORCHETES
‣ Exclusión [^]: Se usa para indicar que en una posición puede encontrarse
cualquier carácter EXCEPTO los que se encuentran entre corchetes.
‣ Ejemplo: c[^aei]s[^ao] => 
casa...mal
cese...mal
cose...bien
cusi...bien
coso...mal
‣ Rangos [-]: Se usa para indicar todos los valores intermedios entre un inicio y un
final. Tienen que ser datos con una ordenación conocida, por ejemplo números o
letras:
‣ Ejemplo: c[a-d]s[0-5] sería igual a c[abcd]s[012345]
Las expresiones se pueden mezclar, por ejemplo: [3-8[:upper:]mty] en esta posición
se admiten números del 3 al 8 ó cualquier mayúscula ó las minúsculas m, t o y.


ejemplo1:
grep "c[^aei]s[^ao]" /usar/share/dict/spanish | tail

con esto le decimos que busque las ultimas 10 palabras que contengan la letra "c" (no forzosamente que empiecen con la letra c)
y despues la vocal que siga no sea ni a,e ó i, que despues siga forzosamente la letra "s" y al final que no siga 
la vocal a ú o  


ejemplo2:
grep "^m[^i-o]s[^f-z].$" /usar/share/dict/spanish

aqui le dcimos que nos busque palabras que comiencen forsozamente con "m" pero que no tengan ninguna vocal en el
rango de i-o luego que siga forzosamente con la letra "s" y la siguiente letra que no sea ninguna en el rango de 
f-z y despues de esa letra con el "." indicamos que lo que siga sea cual quier otro caracter, al final debe ser 
una palabra con 5 caracteres. 




• REPETICIONES (Regex Extendidas)
EXPRESIONES REGULARES
X* El asterisco concuerda con cero o más repeticiones de la expresión regular que le precede (X)
X? El carácter interrogación concuerda con cero o una aparición de la expresión regular que le
precede (X)
X+ El signo más concuerda con una o más repeticiones de la expresión regular que le precede (X)
   esto dice que el valor(X) debe estar obligatoriamente
X{n} Concuerda con n repeticiones exactas de X
X{n,} Concuerda con n o más repeticiones de X, decimos que debe haber un número mínimo de repeticiones
X{,n} Concuerda con cero o a lo sumo n repeticiones de X, decimos que debe de haber un número máximo de repeticiones
X{n,m} Concuerda con al menos n repeticiones de X, o como mucho m repeticiones. decimos que debe tener un mínimo
y un máximo de repeticiones 


ejemplo1:
grep --color -E "^[h-q]{8}$" /usar/share/dict/spanish

con este comando le decimos con grep que busque palabras especificas, con "--color" que al encontrar la plabra
nos coloree las especificaciones que le estamos pidiendo en este caso como le pasamos un parametro ^ al principio de 
las especificaciones y $ al final entonces entendemos que nos coloreará toda la palabra ya que toda la palabra 
tiene que cumplir con especificaciones que en este caso es que sea una palabra formada con las letras del rango de h a q
y le estamos diciendo que esa regle se repita 8 veces osea que la palabra tenga 8 caracteres usando el parametro
de repeticion extendida (por eso usamos el parametro -E al principio)
 
ejemplo2:
grep --color -E "^[h-q]{8,}$" /usar/share/dict/spanish
la misma explicacion anterior pero aqui decimos que minimamente sean 8 caracteres


ejemplo3:
grep --color -E "^[h-q]{,8}$" /usar/share/dict/spanish
la misma explicacion anterior pero aqui decimos que máximo sean 8 caracteres


ejemplo4:
grep --color -E "^[h-q]{4,6}$" /usar/share/dict/spanish
la misma explicacion anterior pero aqui decimos que el número de caracteres sean del rango de 4 a 6 caracteres




• ALTERNATIVA
‣ Se puede usar el operador lógico OR ( | ) para dar por buena cualquiera de las
dos expresiones regulares conectadas.
‣ Ejemplo: ^a.*t$|^e.*x$ => las que empiecen por a y acaben en t o las que
empiecen por e y acaben por x
•AGRUPACIÓN
‣ Se puede usar paréntesis para agrupar expresiones regulares o especificar a qué
debe afectar un determinado carácter especial.
‣ Ejemplo: (c[aeiou]){2} => se tiene que repetir una c seguida de una vocal 2
veces

• ABREVIATURAS
‣ \w => cualquier carácter alfanumérico y el guión bajo (_)
‣ \W => lo contrario de \w, signos de puntuación, espacios, etc..
• LÍMITES DE PALABRA
‣ No representan caracteres, si no límites, estarían entre dos caracteres,
normalmente entre un alfanumérico y uno de puntuación o separadores.
\< Inicio de palabra
\> Fin de palabra
\b Límite de palabra (inicio o fin)
\B Lo contrario a \b. 


• REFERENCIAS: Podemos usar \n siendo n un número entre 1 y 9 para hacer referencia
a una agrupación dentro de la propia expresión regular.
‣ Ejemplo: ([aei])s\1 significa que el primer carácter puede ser a, e o i, luego
una s y el \1 haría referencia que tiene que haber lo mismo que haya en el primer
carácter.
‣ Ejemplo ([[:digit:]])([[:digit:]])0\2\1 expresa que tiene que haber dos
numeres seguidos de un 0 y después el mismo número que esté en la segunda
posición, seguido del mismo número que esté en la primera. Es decir, capicúa,
como 13031, 91019




+++++++++++++++++++++++++++++++++++++Shell Sript+++++++++++++++++++++++++++++++++++++++++++++++++++++

NUESTRO PRIMER SCRIPT
INTRODUCCIÓN

#!/bin/bash
#Este script imprime la frase HOLA MUNDO por pantalla
echo HOLA MUNDO


‣ La primera línea indica la ruta del intérprete, que será el programa encargado de ejecutar las
instrucciones del script. Se debe empezar la linea con los caracteres #!

‣ La segunda es un comentario. Estas lineas son ignoradas por el intérprete. Sirven para hacer aclaraciones
que el programador considere oportunas.
Empiezan por el carácter #

‣ Podemos utilizar cualquier editor de texto para crear el fichero de script. Se suele usar la extensión .sh

‣ Una vez guardado, tenemos que ponerle permisos de ejecución: chmod +x script.sh

• PARÁMETROS
▸ Un script puede recibir información mediante parámetros, que serán cadenas de texto que
pondremos después del nombre del script
▸ Estarán separado por espacios
▸ Dentro del script podremos acceder a ellos mediante variables predefinidas del sistema:
ENTRADA Y SALIDA DE INFORMACIÓN
✓$n => la información de un parámetro en concreto, siendo n un número del parámetro
✓$* => todos los parámetros. Se presentan en una sola cadena de caracteres
✓$@ => todos los parámetros. Es una lista con un elemento por cada parámetro recibido
✓$# => el número de parámetros con los que se ha invocado el script. Será una cifra 

ejemplo1:
nano hola .sh 

aqui creaos un archivo ejecutable en el que pondremos 
#!/bin/bash
#Este script imprime la frase HOLA MUNDO por pantalla
echo HOLA MUNDO


para ver el resultado tendrmos que salir del ejecutable y darle pérmiso de administrador para ejecutar 
el archivo, eso lo hacemos con: chmod + x hola.sh
y lo ejecutamos poniendo "./"  al principio del archivo.





ejemplo2:
podemos poner: head -n1 hola.sh > p1.sh
aqui le decimos que del archivo anterior tome la linea 1 y que la guarde en un nuevo archivo al que 
llamaremos p1.sh

entramos al ejecuable con: nano p1.sh
despues escribimos unas cadenas de carcateres y parámetros:
#!/bin/bash 

echo El primer parámetro es: $1
echo El número de parámetros han sido $#
echo Todos los parámetros son: $*


salimos y ejecutamos otrogando permiso de ejecucion con: chmod +x p1.sh
ejecutamos con: ./p1.sh

pero tambien ingresaremos tras parámetros de modo que quedaría asi:
./p1.sh parametro1 parametro2 parametro3 
 nos arrojara como resultado: 

El primer parámetro es: param1
El número de parámetros han sido: 3
Todos los parámetros son: parametro1 parametro2 parametro3
  


++++++++++++++++++++++++++++++++++++++++++++++++++++Variables+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
    
• VARIABLES
▸ Sirven para guardar información y poder acceder a ella posteriormente
▸ Para referirnos a ellas utilizaremos un identificador que estará compuesto por
caracteres alfa numéricos o guión bajo, pero no pueden empezar por un número
▸ Se distingue entre mayúsculas y minúsculas. $VAR no es igual que $var
ENTRADA Y SALIDA DE INFORMACIÓN
• LECTURA / ESCRITURA DE VARIABLES
▸ Para guardar datos en una variable simplemente tendremos que asignarle un valor, utilizando
su identificador SIN el símbolo del dólar:
 variable=“Hola” (es importante que todo esté junto, sin espacios)
▸ Y para acceder a su contenido usaremos el símbolo del dólar seguido de su identificador:
 echo $variable o llaves: echo ${variable}



ejemplo1:
podemos poner: head -n1 hola.sh > p1.sh
aqui le decimos que del archivo anterior tome la linea 1 y que la guarde en un nuevo archivo al que 
llamaremos p1.sh

entramos al ejecuable con: nano p1.sh
despues escribimos unas cadenas de carcateres y parámetros:
#!/bin/bash 
v1="Hola"
echo $v1 mundo


esto al ejecutarlo nos lanzará en pantalla un "hola mundo"






• MÁS VARIABLES PREDEFINIDAS
▸ Además de las variables para consultar los parámetros, disponemos de algunas similares pero
que contiene otra tipo de información:
ENTRADA Y SALIDA DE INFORMACIÓN
✓$0 => El nombre del script
✓$$ => PID del proceso que se le ha asignado al script en ejecución
✓$? => Resultado devuelto por el último proceso ejecutado.
• VARIABLES DE ENTORNO
▸ Son variables que están definidas en el sistema y que podemos usar si las necesitamos.
▸ Son usadas por el propio sistema para su funcionamiento, por ejemplo $PATH
▸ Podemos ver las disponibles con el comando "printenv"







++++++++++++++++++++++++++++++++++++++++++++++Arrays +++++++++++++++++++++++++++++

DEFINICIÓN
miarray=(dato1 dato2 dato3)
ENTRADA Y SALIDA DE INFORMACIÓN
• LECTURA
${miarray[indice]} => echo ${miarray[0]} ${miarray[1]} ${miarray[-1]}
• OTROS MÉTODOS
▸ Mostrar todos los elementos: ${miarray[*]} o ${miarray[@]}
▸ Mostrar la cantidad de elementos: ${#miarray[@]}
▸ Mostrar todos los indices: ${!miarray[@]}
▸ Eliminar una posición: unset miarray[indice]


ejemplo1:

mia=(p1 p2 p3)
echo ${mia[0]}
echo ${mia[1]}
echo ${mia[2]}
echo ${mia[-1]}
echo ${mia[*]}
echo la cantidad de elementos disponibles son ${#mia[*]}
echo la cantidad de indices disponibles son ${!mia[*]}
unset mia[1]
echo DESPUES DE BORRAR..
echo nos quedan los elementos:  ${mia[*]}
echo la cantidad de elementos disponibles son ${#mia[*]}
echo la cantidad de indices disponibles son ${!mia[*]}


ejecucion:
p1
p2
p3
p3
p1 p2 p3
la cantidad de elementos disponibles son: 3
la cantidad de indices disponibles son: 0 1 2 
DESPUES DE BORRAR..
nos quedan los elementos: p1 p3
la cantidad de elementos disponibles son: 2
la cantidad de indices disponibles son: 0 2


------------------------------------------pedir datos al usuario--------------------------------
usamos read 
ejemplo:1
echo ingresa una palabra:
read variable1
echo tu palabra es:$variable1  

se ejecuta:

ingresa una palabra:
(tabulador en espera que ingreses una palabra)
echo tu palabra es:$variable1

podemos evitar el salo de linea en automatico que produce el tabulador al querer recibir un dato por el read 
poniendo -n al principio del echo que anteceda al read. 

ejemplo2:
echo -n ingresa una palabra:
read variable1
echo tu palabra es:$variable1  


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++Operaciones aritmeticas ++++++++++++++++++++++++++++++++++++++++++
Operaciones aritméticas
OPERACIONES ARITMÉTICAS Y LÓGICAS
+ Suma
- Resta
* Multiplicación
/ División
% Resto de la División

Para que se ejecute la operación tendremos que ponerla dentro de $(( ))
echo 1+1 => sacará por pantalla 1+1
echo $((1+1)) => sacará por pantalla 2

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Condicionales++++++++++++++++++++++++++++++++++++++++++
• Operaciones condicionales
‣ Su objetivo es comprobar si una expresión es verdadera o falsa.
‣ Realizan comparaciones o comprueban si se cumplen condiciones.
‣ Utilizamos el comando test. Se puede poner de dos formas
 test expresión o [ expresión ]
Ejemplos:
Si queremos comparar si un numero es mayor a otro ponemos: 
‣ test 10 -gt 20           ó            [ 10 -gt 20 ]
´i queremoscomparar dos cadenas de texto ponemos:
‣ test ‘hola’ = ‘holita’            ó             [ ‘hola’ = ‘holita’ ]
comprobamos si una ruta es un directorio:
‣ test -d /etc/                   ó             [ -d /etc/ ]

*Comparación de números

SINTAXIS                         DESCRIPCIÓN
ENTERO1 -eq ENTERO2      ENTERO1 es igual que ENTERO2
ENTERO1 -ge ENTERO2      ENTERO1 es mayor o igual que ENTERO2
ENTERO1 -gt ENTERO2      ENTERO1 es mayor que ENTERO2
ENTERO1 -le ENTERO2      ENTERO1 es menor que o igual que ENTERO2
ENTERO1 -lt ENTERO2      ENTERO1 es menor que ENTERO2
ENTERO1 -ne ENTERO2      ENTERO1 no es igual que ENTERO2

• Sentencia condicional IF
‣ Ejecuta una o varias instrucciones sólo si se cumple una condición
‣ Sintaxis:
if CONDICION; then
   comandos
fi

‣ Ejemplo:

if [ $v1 -gt $v2 ]; then
 echo “La variable v1 es mayor que v2”
fi


fi solo nos sirve para cerrar el condicional es como si fuera la ultima llave 
si programaramos en c++ o python.